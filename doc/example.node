
# Data
# --------
# Stream    | (Stream)     | related ordered data representation- bundled into tokens (chunks). A gradually consumed state
# Token     | (Chunk)      | coherent instance of stream data being mutated and passing through the pipelines (potentially in parallel) - special values of EOF & Exceptionals
#
# Nodes
# -------
# Consumer  | (Iteratee)   | folds over one or more input streams & emits nothing except a final result/stats if the done/EOF token is encountered.
# Generator | (Enumerator) | data producer with no input (composition == concatenation of token pieces?)
# Operator  | (Enumeratee) | stream transformer. acts as both a consumer & generator (speaking of mutations of a single stream or the creation of new streams?)
#


# Token: any object instance but usually openstruct with hash-like access as well (so like HashWithIndifferentAccess) but with
# WRITE-ONCE semantics! (throws error if the same process/node tries to write the same field a second time)
#
# suggested behavior:
#   - lock-field-value-on-write
#   - unlock-all-field-values (for when a node starts its turn | possibly specify that this proc/node is one that can write to it)
#   - exception on rewrite of a field after it's locked
#   - 
#   - "type-signature"
#     - optional? used to specify duck-typing-behavior desired...
#     - (terminals)
  #     - prettified class-name unless class-name is openstruct or a collection like hash
  #     - '__sig__' attribute or lookup
#       - (something for member sig for an Array...)
#       - 
#   - can enumerate fields (via :fields, :to_h.keys)
#   - or a 
#



# Generator from simple-proc
# Generator from Enum
# Generator from Lazy Enumerator
# Generator from basic class
# Generator from basic class via to_enum
# Generator from state-machine
# Generator from DSL



# data splitting - add selected field to path? (for example, bid vs ask)




